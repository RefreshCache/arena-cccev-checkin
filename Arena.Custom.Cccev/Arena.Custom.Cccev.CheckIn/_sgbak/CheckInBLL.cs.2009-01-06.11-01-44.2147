/**********************************************************************
* Description:
* Created By:	
* Date Created:	
*
* $Workfile: CheckInBLL.cs $
* $Revision: 12 $ 
* $Header: /trunk/Arena.Custom.Cccev/Arena.Custom.Cccev.CheckIn/CheckInBLL.cs   12   2009-01-05 22:15:23-07:00   nicka $
* 
* $Log: /trunk/Arena.Custom.Cccev/Arena.Custom.Cccev.CheckIn/CheckInBLL.cs $
*  
*  Revision: 12   Date: 2009-01-06 05:15:23Z   User: nicka 
*  set label values 
*  
*  Revision: 11   Date: 2009-01-06 00:08:52Z   User: JasonO 
*  
*  Revision: 10   Date: 2009-01-06 00:07:03Z   User: JasonO 
*  Updating to current code. 
*  
*  Revision: 9   Date: 2009-01-05 16:55:54Z   User: JasonO 
*  
*  Revision: 8   Date: 2008-12-30 18:06:05Z   User: JasonO 
*  
*  Revision: 7   Date: 2008-12-23 20:20:43Z   User: JasonO 
*  updating latest changes 
*  
*  Revision: 6   Date: 2008-12-18 22:57:18Z   User: JasonO 
*  
*  Revision: 5   Date: 2008-12-10 00:29:12Z   User: JasonO 
*  Updating static bll methods. 
*  
*  Revision: 4   Date: 2008-12-02 00:14:38Z   User: nicka 
*  
*  Revision: 3   Date: 2008-12-02 00:10:49Z   User: JasonO 
*  
*  Revision: 2   Date: 2008-11-20 23:13:05Z   User: JasonO 
*  Creating facade to abastract logic of business objects from UI. 
*  
*  Revision: 1   Date: 2008-11-12 21:53:34Z   User: nicka 
**********************************************************************/
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Linq;

using Arena.Computer;
using Arena.Core;
using Arena.DataLayer.Core;
using Arena.DataLayer.Organization;
using Arena.Organization;

using Arena.Custom.Cccev.CheckIn.Entity;
using Arena.Custom.Cccev.DataUtils;

namespace Arena.Custom.Cccev.CheckIn
{
	/// <summary>
	/// CheckIn constants
	/// </summary>
	[Serializable]
	public class Constants
	{
		public const string SESS_HOME = "CCCEV_CHECKIN_HOME";
		public const string SESS_CAMPUSCODE = "CCCEV_CHECKIN_CAMPUSCODE";
		public const string QS_KEY_FAMILY_ID = "scanID";
        public const string SESS_STATE = "CCCEV_CHECKIN_STATE";

		public const string SESS_KEY_CHILDREN = "cccev_checkinChildren";
		public const string SESS_KEY_PEOPLEMAP = "cccev_peopleMap";
		public const string SESS_HASH_CHECKIN_PEOPLE_IDS = "cccev_checkinPeopleHash";
        public const string SESS_FAMILY = "cccev_checkInFamily";
		public const string SESS_LIST_CHECKIN_FAMILYMEMBERS = "cccev_checkinFamilyMemberList";
        public const string SESS_ATTENDEES = "cccev_checkinAttendees";
		public const string SESS_LIST_OCCURRENCES_CHECKIN = "cccev_checkinOccurrences";
        public const string SESS_SERVICE_TIMES = "serviceTimes";
        public const string SESS_RESULTS = "checkinResults";

		public static readonly DateTime NULL_DATE = DateTime.Parse( "1/1/1900" );

		public const int ORGANIZATION_ID = 1;
	}

    public enum CheckInStates
    {
        Init,
        FamilySearch,
        SelectFamilyMember,
        NoEligiblePeople,
        SelectAbility,
        SelectService,
        Confirm,
        Result,
        BadKiosk
    }

    public enum SearchTypes
    { 
        Scanner,
        PhoneNumber
    }

    [Serializable]
    public class Controller
    {
        private static string _promotionMMDD = null;

        public static string PromotionMMDD
        {
            get
            {
                if (_promotionMMDD == null)
                    _promotionMMDD = new OrganizationSettingData().GetOrganizationSetting(Constants.ORGANIZATION_ID, "GradePromotionDate");
                
                return _promotionMMDD;
            }
        }

        /// <summary>
        /// Determines whether or not a family member is allowed to check into a given occurrence attendance.
        /// </summary>
        /// <param name="fm"><see cref="Arena.Core.FamilyMember">FamilyMember</see> to check in</param>
        /// <param name="oa"><see cref="Arena.Core.OccurrenceAttendance">OccurrenceAttendance</see> to check into</param>
        /// <param name="maxAge">Maximum age</param>
        /// <param name="maxGrade">Maximum grade level</param>
        /// <returns>bool indicating whether or not Family Member can check in to Occurrence Attendance</returns>
        public static bool CanCheckIn(FamilyMember fm, OccurrenceAttendance oa, int maxAge, int maxGrade)
        {
            bool result = true;
            
            bool checkedIn = oa.CheckInTime != Constants.NULL_DATE;
            bool gradDateKnown = fm.GraduationDate != Constants.NULL_DATE;
            bool graduated = MaxGradeGradDate(fm, maxGrade) > DateTime.Now;
            bool isYoungEnough = fm.Age < maxAge;

            if (!checkedIn)
            {
                if (gradDateKnown)
                {
                    if (!graduated)
                        result = true;
                    else
                        result = false;
                }
                else if (fm.Age != -1)
                {
                    if (maxAge != -1)
                    {
                        if (isYoungEnough)
                            result = true;
                        else
                            result = false;
                    }
                    else
                        result = true;
                }
                else
                    result = true;
            }
            else
                result = false;

            return result;
        }

        private static DateTime MaxGradeGradDate(Person person, int maxGrade)
        {
            // Where the date is: MM/DD/YYYY (7 years before their HS Grad year)
            return DateTime.Parse(string.Format("{0}/{1}", PromotionMMDD, (person.GraduationDate.Year - maxGrade)));
        }

        /// <summary>
        /// Determines whether or not any user has the ability to check in to the provided Occurrence.
        /// </summary>
        /// <param name="occurrence"><see cref="Arena.Core.Occurrence">Occurrence</see> to check into</param>
        /// <returns>bool indicating whether or not Occurrence's checkin start time has passed</returns>
        public static bool ReadyForCheckIn(Occurrence occurrence)
        {
            return (occurrence.CheckInStart <= DateTime.Now);
        }

        /// <summary>
        /// Gets a family based on the specified search type and value provided.
        /// </summary>
        /// <param name="searchType">Enum that determines the type of search being done (by barcode, or by phone number)</param>
        /// <param name="value">Family ID or phone number</param>
        /// <returns>Collection of families that match the criteria provided</returns>
        public static FamilyCollection GetFamily(SearchTypes searchType, string value)
        {
            FamilyCollection families;

            switch (searchType)
            {
                case SearchTypes.Scanner:
                    families = GetFamiliesByAltID(value);
                    break;
                case SearchTypes.PhoneNumber:
                    families = GetFamiliesByPhoneNumber(value);
                    break;
                default:
                    families = new FamilyCollection();
                    break;
            }

            return families;
        }

        private static FamilyCollection GetFamiliesByAltID(string altID)
        {
            FamilyCollection families = new FamilyCollection();
            Person person = new Person();
            person.LoadByAlternateID(altID);
            families.Add(person.Family());
            return families;
        }

        private static FamilyCollection GetFamiliesByPhoneNumber(string phone)
        {
            FamilyCollection families = new FamilyCollection();
            families.LoadByPhoneNumber(phone);
            return families;
        }

        /// <summary>
        /// Overload to only pass family.
        /// </summary>
        /// <param name="family"><see cref="Arena.Core.Family">Family</see> to find relatives for</param>
        /// <returns><see cref="Arena.Core.FamilyMemberCollection">FamilyMemberCollection</see> of current family and any relatives</returns>
        public static FamilyMemberCollection GetRelatives(Family family)
        {
            return GetRelatives(family, new int[0]);
        }

        /// <summary>
        /// Creates a FamilyMemberCollection of provided family's members and any relationships whose type matches one of the array members.
        /// </summary>
        /// <param name="family"><see cref="Arena.Core.Family">Family</see> to find relatives for</param>
        /// <param name="relationshipTypeIDs">int array of Relationship ID's</param>
        /// <returns><see cref="Arena.Core.FamilyMemberCollection">FamilyMemberCollection</see> of current family and any relatives</returns>
        public static FamilyMemberCollection GetRelatives(Family family, int[] relationshipTypeIDs)
        {
            FamilyMemberCollection familyMembers = family.FamilyMembers;

            if (relationshipTypeIDs.Length > 0)
            {
                FamilyMember fm = family.FamilyHead;

                foreach (Relationship rel in fm.Relationships)
                {
                    foreach (int i in relationshipTypeIDs)
                    {
                        if (rel.RelationshipTypeId == i)
                            familyMembers.Add(new FamilyMember(rel.RelatedPersonId));
                    }
                }
            }

            return familyMembers;
        }
        
        /// <summary>
        /// Loads the active occurrences based on the location of the kiosk passed in and will create
        ///  a filtered OccurrenceCollection based on start and end dates.
        /// </summary>
        /// <param name="startDate">DateTime to start filter</param>
        /// <param name="endDate">DateTime to end filter</param>
        /// <param name="kiosk"><see cref="Arena.Computer.ComputerSystem">ComputerSystem</see> kiosk</param>
        /// <returns>Filtered IEnumerable</returns>
        public static IEnumerable<Occurrence> GetOccurrences(DateTime lookAhead, DateTime currentTime, ComputerSystem kiosk)
        {
            OccurrenceCollection oc = new OccurrenceCollection();
            oc.LoadOccurrencesBySystemIDAndDateRange(kiosk.SystemId, currentTime, lookAhead);
            
            return (from o in oc 
                    select o).Distinct();
        }

        /// <summary>
        /// Creates an OccurrenceCollection based on the criteria passed in.
        /// </summary>
        /// <param name="occurrenceEvents">IEnumerable collection of Occurrences to filter</param>
        /// <param name="person"><see cref="Arena.Core.FamilyMember">FamilyMember</see> to filter occurrences for</param>
        /// <param name="serviceTimes">Generic list of service times to filter by</param>
        /// <param name="abilityAttributeID">ID representing an Ability Level PersonAttribute</param>
        /// <param name="specialNeedsAttributeID">ID representing a Special Needs PersonAttribute</param>
        /// <returns>Filtered <see cref="Arena.Core.OccurrenceCollection">OccurrenceCollection</see></returns>
        public static IEnumerable<Occurrence> FilterOccurrences(IEnumerable<Occurrence> occurrenceEvents, FamilyMember person,
            List<DateTime> serviceTimes, int abilityAttributeID, int specialNeedsAttributeID)
        {
            Dictionary<DateTime, Occurrence> filteredOccurrences = new Dictionary<DateTime, Occurrence>();

            // Filtering occurrence collection by start time
            var classes = (from o in occurrenceEvents
                           where serviceTimes.Contains(o.StartTime)
                           select o).Distinct();

            /// loop through each class occurrence and constrain choices by
            /// age/grade, special needs, ability level, etc
            foreach (Occurrence occurrence in classes)
            {
                // Check to see if filteredOccurrences already has an object w/ the same
                // start time. If it does, then no need to add another one with the same key.
                if (!filteredOccurrences.ContainsKey(occurrence.StartTime))
                {
                    // Now check existing Arena criteria
                    if (RequireAgeAndGrade(person, occurrence.OccurrenceType) &&
                        RequireGender(person, occurrence.OccurrenceType))
                    {
                        // Filter by custom criteria
                        OccurrenceTypeAttributeCollection occurrenceTypeAttributes = new OccurrenceTypeAttributeCollection(occurrence.OccurrenceTypeID);
                        OccurrenceTypeAttribute ota = occurrenceTypeAttributes[0];

                        if (ota.OccurrenceTypeAttributeId != -1)
                        {
                            if (RequireSpecialNeeds(person, ota, specialNeedsAttributeID) &&
                                RequireAbilityLevel(person, ota, abilityAttributeID) &&
                                RequireLastName(person, ota))
                            {
                                filteredOccurrences.Add(occurrence.StartTime, occurrence);
                            }
                        }
                        else
                        {
                            filteredOccurrences.Add(occurrence.StartTime, occurrence);
                        }
                    }
                }
            }

            List<Occurrence> matchingClasses = new List<Occurrence>();

            foreach (DateTime service in serviceTimes)
            {
                if (filteredOccurrences.ContainsKey(service))
                    yield return filteredOccurrences[service];
                else
                    yield return GetEmptyOccurrence(service);
            }
        }

        /// <summary>
        /// Iterates through Dictionary of family members, checks them in, and returns a Generic List of status strings.
        /// </summary>
        /// <param name="familyMap">Generic Dictionary of FamilyMembers (key) and OccurrenceCollections (value)</param>
        /// <returns>Generic List of status messages</returns>
        public static IEnumerable<string> CheckInFamily(Dictionary<FamilyMember, IEnumerable<Occurrence>> familyMap)
        {
            List<string> resultList = new List<string>();

            foreach (KeyValuePair<FamilyMember, IEnumerable<Occurrence>> person in familyMap)
            {
                yield return CheckInFamilyMember(person.Key, person.Value);
            }
        }

        /// <summary>
        /// Checks in an individual attendee.
        /// </summary>
        /// <param name="attendee"><see cref="Arena.Core.FamilyMember">FamilyMember</see> to check in</param>
        /// <param name="occurrences"><see cref="Arena.Core.OccurrenceCollection">OccurrenceCollection</see> of Occurrences attendee can check into</param>
        /// <returns>Status variable to be displayed on the view</returns>
        private static string CheckInFamilyMember(FamilyMember attendee, IEnumerable<Occurrence> occurrences)
        {
            bool success = true;
            string output = string.Empty;
            OccurrenceAttendance firstAttendance = null;

            foreach (Occurrence occurrence in occurrences)
            {
                try
                {
                    if (occurrence is EmptyOccurrence || occurrence.OccurrenceID.Equals(-1))
                        success = false;
                    else
                    {
                        OccurrenceAttendance attendance = new OccurrenceAttendance();
                        attendance.OccurrenceID = occurrence.OccurrenceID;
                        attendance.PersonID = attendee.PersonID;
                        ISecurityCode securityCode =
                            SecurityCodeHelper.GetSecurityCodeClass(SecurityCodeHelper.DefaultSecurityCodeSystem(ArenaContext.Current.Organization.OrganizationID));
                        attendance.SecurityCode = securityCode.GetSecurityCode();
                        attendance.Attended = true;
                        attendance.CheckInTime = DateTime.Now;
                        attendance.Save(ArenaContext.Current.User.Identity.Name);

                        if (firstAttendance == null)
                            firstAttendance = attendance;
                    }
                }
                catch (SqlException ex)
                {
                    success = false;
                    output = string.Format("Error: Checkin failure for {0}! - <br /> {1}", attendee.FullName, ex.Message);

                    try
                    {
                        // If SQL exception is generated, we want to log it w/o taking the user out of the checkin app
                        new ExceptionHistoryData().AddUpdate_Exception(ex, ArenaContext.Current.Organization.OrganizationID,
                            ArenaContext.Current.User.Identity.Name, ArenaContext.Current.ServerUrl);
                    }
                    catch (Exception e)
                    {
                        throw e;
                    }
                }
            }

            if (success)
                output = PrintLabel(attendee, occurrences, firstAttendance);

            return output;
        }

        /// <summary>
        /// Tells printer to print CheckIn label.
        /// </summary>
        /// <param name="attendee"><see cref="Arena.Core.FamilyMember">FamilyMember</see> attending occurrence</param>
        /// <param name="occurrences"><see cref="Arena.Core.OccurrenceCollection">OccurrenceCollection</see> of Occurrences the attendee can check into</param>
        /// <param name="attendance"><see cref="Arena.Core.OccurrenceAttendance">OccurrenceAttendance</see>to be updated with failure status if print job fails</param>
        /// <returns>Status variable to be displayed on the view</returns>
        private static string PrintLabel(FamilyMember attendee, IEnumerable<Occurrence> occurrences, OccurrenceAttendance attendance)
        {
            Check label = new PrinterLabel();
            Location location = new Location(occurrences.First().LocationID);

            try
            {
                label.FirstName = attendee.FirstName;
                label.LastName = attendee.LastName;
				label.FullName = attendee.FirstName + " " + attendee.LastName;
                label.SecurityToken = attendance.SecurityCode;
                label.CheckInDate = attendance.CheckInTime;

                /// TO DO:  Determine how we want to get these "configurable" settings
				/// passed module settings via module, or org settings, or config setting?
				/*
				label.ClaimCardSubTitle = ConfigurationSettings.AppSettings[ "ClaimCard.ClaimCardSubTitle" ];
				label.DateTitle = ConfigurationSettings.AppSettings[ "ClaimCard.DateLabel" ];
				label.ServicesTitle = ConfigurationSettings.AppSettings[ "ClaimCard.ServicesLabel" ];
				label.SecurityTokenTitle = ConfigurationSettings.AppSettings[ "ClaimCard.SecurityCodeLabel" ];
				label.Footer = ConfigurationSettings.AppSettings[ "ClaimCard.Footer" ];
				label.AttendanceLabelTitle = ConfigurationSettings.AppSettings[ "ClaimCard.AttendanceLabelTitle" ];
				label.ClaimCardTitle = ConfigurationSettings.AppSettings[ "ClaimCard.ClaimCardTitle" ];
				label.HealthNotesTitle = ConfigurationSettings.AppSettings[ "ClaimCard.HealthNotesTitle" ];
				label.ParentsInitialsTitle = ConfigurationSettings.AppSettings[ "ClaimCard.ParentsInitialsTitle" ];
				*/

				label.Services = occurrences.First().StartTime.ToShortTimeString();
				foreach ( Occurrence o in occurrences )
				{
					label.Services += ", " + o.StartTime.ToShortTimeString();
				}

				label.AgeGroup = occurrences.First().Name;
				label.BirthdayDate = attendee.BirthDate;
				
				// TO DO: Decide how to get the values for the given attendee's attributes:
				//	Is Allowed to Self Check-Out
				//	Legal Notes
				//  Health Notes
				/*
				label.SelfCheckOutFlag = attendee.IsAllowedToSelfCheckOut;
				label.LegalNoteFlag = ( "".Equals( attendee.LegalNotes.Trim() ) ) ? false : true;
				if ( "".Equals( attendee.HealthNotes.Trim() ) )
				{
					label.HealthNoteFlag = false;
				}
				else
				{
					label.HealthNoteFlag = true;
					label.HealthNotes = attendee.HealthNotes;
				}
				*/

                /// TO DO:  Printer needs to be registered in Arena and print labels need to be populated before the code below can be called.
                /// label.PrintAllLabels(location.Printer.PrinterName);
                return string.Format("{0} checked in successfully in room {1}.", attendee.FullName, occurrences.First().Location);
            }
            catch
            {
                attendance.Notes = string.Format("Print Failure: {0}", location.Printer.PrinterName);
                attendance.Save(ArenaContext.Current.User.Identity.Name);
                return string.Format("Error: {0} checked in successfully to room {1}, but their badge failed to print.", 
                    attendee.FullName, occurrences.First().Location);
            }
        }

        private static Occurrence GetEmptyOccurrence(DateTime startTime)
        {
            return new EmptyOccurrence(startTime);
        }

        /// <summary>
        /// Shortens and adds an elipsis ("...") to provides string to 36 characters.
        /// </summary>
        /// <param name="text">string to shorten</param>
        /// <returns>Truncated string</returns>
        public static string TruncateText(string text)
        {
            if (text.Length >= 36)
                return text.Substring(0, 35) + "...";
            else
                return text;
        }

        /// <summary>
        /// Determines whether or not age or grade are required for checkin.
        /// </summary>
        /// <param name="person"><see cref="Arena.Core.FamilyMember">FamilyMember</see> to test against</param>
        /// <param name="attribute"><see cref="Arena.Core.OccurrenceType">OccurrenceType</see> that determines test criteria</param>
        /// <returns>bool based on whether the person's age or grade falls within the allowable ages or grades</returns>
        private static bool RequireAgeAndGrade(FamilyMember person, OccurrenceType type)
        {
            bool result = false;

            if (type.MinGrade != -1 || type.MaxGrade != -1)
            {
                int gradeLevel = Person.CalculateGradeLevel(person.GraduationDate, ArenaContext.Current.Organization.GradePromotionDate);
                result = (gradeLevel >= type.MinGrade && gradeLevel <= type.MaxGrade);
            }
            else if ((type.MinAge != 0 || type.MaxAge != 0) && 
                (type.MinAge != -1 || type.MaxAge != -1))
            {
                decimal fractionalAge = DateUtils.GetFractionalAge(person.BirthDate);
                result = (fractionalAge >= type.MinAge && fractionalAge <= type.MaxAge);
            }
            else
                result = true;

            return result;
        }

        /// <summary>
        /// Determines whether or not special needs is required for checkin.
        /// </summary>
        /// <param name="person"><see cref="Arena.Core.FamilyMember">FamilyMember</see> to test against</param>
        /// <param name="attribute"><see cref="Arena.Custom.Cccev.CheckIn.OccurrenceTypeAttribute">OccurrenceTypeAttribute</see> that determines test criteria</param>
        /// <param name="attributeID">ID representing a Special Needs PersonAttribute</param>
        /// <returns>bool based on whether the person attribute matches the OccurrenceTypeAttribute's requirement for special needs</returns>
        private static bool RequireSpecialNeeds(FamilyMember person, OccurrenceTypeAttribute attribute, int attributeID)
        {
            bool result = false;

            if (!attribute.IsSpecialNeeds)
                result = true;
            else
            {
                PersonAttribute pa = new PersonAttribute(person.PersonID, attributeID);
                bool specialNeeds = pa.IntValue == 1;  // Arena Framework uses int values in Person Attribute to reflect true/false
                result = (specialNeeds == attribute.IsSpecialNeeds);
            }

            return result;
        }

        /// <summary>
        /// Determiens whether or not certain ability levels are required for checkin.
        /// </summary>
        /// <param name="person"><see cref="Arena.Core.FamilyMember">FamilyMember</see> to test against</param>
        /// <param name="attribute"><see cref="Arena.Custom.Cccev.CheckIn.OccurrenceTypeAttribute">OccurrenceTypeAttribute</see> that determines test criteria</param>
        /// <param name="attributeID">ID representing an Ability Level PersonAttribute</param>
        /// <returns>bool based on whether the person attribute matches the OccurrenceTypeAttribute's requirement for ability level</returns>
        private static bool RequireAbilityLevel(FamilyMember person, OccurrenceTypeAttribute attribute, int attributeID)
        {
            bool result = false;

            if (attribute.AbilityLevel.Value.ToUpper() == "UNKNOWN")
                result = true;
            else
            {
                PersonAttribute pa = new PersonAttribute(person.PersonID, attributeID);
                result = (new Lookup(pa.IntValue).Value == attribute.AbilityLevel.Value);
            }

            return result;
        }

        /// <summary>
        /// Determines whether or not gender is required for checkin.
        /// </summary>
        /// <param name="person"><see cref="Arena.Core.FamilyMember">FamilyMember</see> to test against</param>
        /// <param name="type"><see cref="Arena.Core.OccurrenceType">OccurrenceType</see> that determines test criteria</param>
        /// <returns>bool based on whether the person's gender matches the gender requirement of the occurrence type</returns>
        private static bool RequireGender(FamilyMember person, OccurrenceType type)
        {
            bool result = false;

            if (type.GenderPreference == GenderPreference.Everyone)
                result = true;
            else
                result = (person.Gender.ToString() == type.GenderPreference.ToString());

            return result;
        }

        /// <summary>
        /// Determines whether or not last initial needs to fall within a given range for checkin.
        /// </summary>
        /// <param name="person"><see cref="Arena.Core.FamilyMember">FamilyMember</see> to test against</param>
        /// <param name="attribute"><see cref="Arena.Custom.Cccev.CheckIn.OccurrenceTypeAttribute">OccurrenceTypeAttribute</see> that determines test criteria</param>
        /// <returns>bool based on whether the person's last initial falls within the range required by the occurrence type attribute</returns>
        private static bool RequireLastName(FamilyMember person, OccurrenceTypeAttribute attribute)
        {
            bool result = false;

            if (attribute.LastNameStartingLetter.Trim() == string.Empty && attribute.LastNameEndingLetter.Trim() == string.Empty)
                result = true;
            else
            {
                char rangeStart = 'A';
                char rangeEnd = 'Z';
                
                if (attribute.LastNameStartingLetter.Trim() != string.Empty)
                    rangeStart = char.Parse(attribute.LastNameStartingLetter.ToUpper());

                if (attribute.LastNameEndingLetter.Trim() != string.Empty)
                    rangeEnd = char.Parse(attribute.LastNameEndingLetter.ToUpper());

                char lastInitial = char.Parse(person.LastName.Substring(0, 1).ToUpper());
                result = (lastInitial >= rangeStart && lastInitial <= rangeEnd);
            }

            return result;
        }
    }
}
